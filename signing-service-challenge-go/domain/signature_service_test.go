package domain

import (
	"encoding/base64"
	"errors"
	"fmt"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var testAlgorithms = map[string]Algorithm[KeyPair]{
	"Dummy": dummyAlgorithm{},
}

type dummyAlgorithm struct{}

func (d dummyAlgorithm) CreateKeyPair() (KeyPair, error) {
	return "the key", nil
}

func (d dummyAlgorithm) SignData(data string, keyPair KeyPair) ([]byte, error) {
	if keyPair != "the key" {
		// TODO: handle this differently, either with a specific test or passing the testing.T
		return nil, errors.New("The key was not generated by this algorithm")
	}
	return []byte(data), nil
}

func (d dummyAlgorithm) Marshal(KeyPair KeyPair) ([]byte, []byte, error) {
	return []byte("public key"), []byte("private key"), nil
}

func (d dummyAlgorithm) Unmarshal(privateKeyBytes []byte) (KeyPair, error) {
	privateKey := string(privateKeyBytes)
	if privateKey != "private key" {
		return "", errors.New("Invalid key")
	}
	return "the key", nil
}

func TestGenerateSecureDataToBeSign(t *testing.T) {
	message := "this is the data"
	lastSignature := "last signature"
	lastSignatureBase64 := base64.StdEncoding.EncodeToString([]byte(lastSignature))
	deviceId, error := uuid.NewRandom()
	require.Nil(t, error)

	t.Run("Initial signature with counter 0", func(t *testing.T) {
		signatureCount := 0

		got := generateSecureDataToBeSign(signatureCount, message, lastSignatureBase64, deviceId)
		deviceIdBase64 := base64.StdEncoding.EncodeToString(deviceId[:])
		expect := fmt.Sprintf("%d_%s_%s", signatureCount, message, deviceIdBase64)
		assert.Equal(t, expect, got)
	})

	t.Run("Subsequent signature with counter > 0", func(t *testing.T) {
		signatureCount := 1

		got := generateSecureDataToBeSign(signatureCount, message, lastSignatureBase64, deviceId)
		expect := fmt.Sprintf("%d_%s_%s", signatureCount, message, lastSignatureBase64)
		assert.Equal(t, expect, got)
	})
}

func TestMarshalAndUnmarshalDevice(t *testing.T) {
	repository := NewInMemoryRepository()
	signatureService, err := NewSignatureService(testAlgorithms, repository)
	require.Nil(t, err)
	deviceId, err := signatureService.NewSignatureDevice("Dummy", "first device")
	require.Nil(t, err)
	device, err := signatureService.getDevice(deviceId)
	require.Nil(t, err)
	marshalDevice, err := signatureService.marshalDevice(device)
	assert.Nil(t, err)
	unmarshalDevice, err := signatureService.unmarshalDevice(marshalDevice)
	assert.Nil(t, err)
	assert.Equal(t, device, unmarshalDevice)
}

func TestNewSignatureService(t *testing.T) {
	t.Run("Empty algorithms", func(t *testing.T) {
		emptyAlgorithms := make(map[string]Algorithm[KeyPair])
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(emptyAlgorithms, repository)
		assert.Nil(t, signatureService)
		assert.NotNil(t, err)
	})

	t.Run("With algorithms", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		assert.Nil(t, err)
		assert.NotNil(t, signatureService)
	})
}

func TestNewSignatureDevice(t *testing.T) {
	t.Run("With inexisting algorithm", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		_, err = signatureService.NewSignatureDevice("RSA", "first device")
		assert.EqualError(t, err, "algorithm RSA not in algorithms")
	})

	t.Run("With correct algorithm", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		deviceId, err := signatureService.NewSignatureDevice("Dummy", "first device")
		assert.Nil(t, err)
		devices, err := signatureService.GetDevices()
		assert.Nil(t, err)
		assert.Len(t, devices, 1)
		device := devices[0]
		assert.Equal(t, 0, device.Counter)
		assert.Equal(t, deviceId, device.ID)
	})
}

func TestSignatureServiceSign(t *testing.T) {
	t.Run("Sign data first time", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		deviceId, err := signatureService.NewSignatureDevice("Dummy", "first device")
		require.Nil(t, err)
		message := "this is the data"
		signature, _, err := signatureService.SignData(deviceId, message)
		assert.Nil(t, err)
		deviceIdBase64 := base64.StdEncoding.EncodeToString(deviceId[:])
		specialString := fmt.Sprintf("%d_%s_%s", 0, message, deviceIdBase64)
		expect := base64.StdEncoding.EncodeToString([]byte(specialString))
		assert.Equal(t, expect, signature)
	})

	t.Run("Sign data multiple times", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		deviceId, err := signatureService.NewSignatureDevice("Dummy", "first device")
		require.Nil(t, err)
		message := "this is the data"
		signature, _, err := signatureService.SignData(deviceId, message)
		require.Nil(t, err)
		newSignature, _, err := signatureService.SignData(deviceId, message)
		specialString := fmt.Sprintf("%d_%s_%s", 1, message, signature)
		expect := base64.StdEncoding.EncodeToString([]byte(specialString))
		assert.Equal(t, expect, newSignature)
	})
}

func TestListSignatureDevice(t *testing.T) {
	t.Run("Empty list", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		devices, err := signatureService.GetDevices()
		assert.Nil(t, err)
		assert.Len(t, devices, 0)
	})
	t.Run("Not empty list", func(t *testing.T) {
		repository := NewInMemoryRepository()
		signatureService, err := NewSignatureService(testAlgorithms, repository)
		require.Nil(t, err)
		_, err = signatureService.NewSignatureDevice("Dummy", "first device")
		require.Nil(t, err)
		devices, err := signatureService.GetDevices()
		assert.Nil(t, err)
		assert.Len(t, devices, 1)
	})
}
